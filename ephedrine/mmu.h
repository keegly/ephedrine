#ifndef MMU_H
#define MMU_H

#include <array>
#include <vector>

enum class CartridgeType {
  kROMOnly = 0,
  kMBC1,
  kMBC1wRAM,
  kMBC1wRAMwBattery,
  kMBC2 = 0x05,
  kMBC2wBattery,
  kROMRAM = 0x08,
  kROMRAMwBattery,
  kMMM01 = 0x0b,
  kMMM01wRAM,
  kMMM01wRAMwBattery,
  kMBC3wTimerwBattery = 0x0f,
  kMBC3wTimerwRAMwBattery,
  kMBC3,
  kMBC3wRAM,
  kMBC3wRAMwBattery,
  kMBC5 = 0x19,
  kMBC5wRAM,
  kMBC5wRAMwBattery,
  kMBC5wRumble,
  kMBC5wRumblewRAM,
  kMBC5wRumblewRAMwBattery,
  kMBC6 = 0x20,
  kMBC7wSensorwRumblewRAMwBattery = 0x22,
  kPocketCamera = 0xFC,
  kBandaiTama5,
  kHuC3,
  kHuC1wRAMwBattery
};
class MMU {
 public:
  MMU() = default;
  MMU(std::vector<uint8_t> &cart, bool boot_rom = false);
  void ShowDebugWindow();
  void Load(std::vector<uint8_t> &c);
  uint8_t ReadByte(uint16_t address);
  void WriteByte(uint16_t address, uint8_t value);
  void SetRegister(uint16_t reg, uint8_t val);
  uint8_t GetRegister(uint16_t reg);
  void SetPPUMode(uint8_t mode);
  void SaveBufferedRAM(std::ofstream &ofs);
  void LoadBufferedRAM(std::ifstream &ifs);
  size_t CartridgeSize() const { return cartridge_.size(); }
  std::unique_ptr<std::vector<uint8_t>> DebugShowMemory(
      uint16_t start_address, uint16_t end_address) const {
    std::vector<uint8_t> memory{memory_.begin() + start_address,
                                memory_.begin() + end_address + 1};
    return std::make_unique<std::vector<uint8_t>>(memory);
  }
  // total amount of 8kB memory banks we have
  int rom_banks = 0;
  int num_ram_banks = 0;
  bool boot_rom_enabled = true;
  bool cart_ram_modified = false;
  template <class Archive>
  void serialize(Archive &archive) {
    archive(rom_banks, num_ram_banks, cart_ram_modified, memory_, ram_banks_,
            active_rom_bank_, active_ram_bank_, ram_banking_mode_,
            ram_enabled_);
  }

 private:
  std::array<uint8_t, 0x10000> memory_{};
  std::vector<uint8_t> cartridge_{};
  std::vector<std::array<uint8_t, 0x4000>> cart_rom_banks_{};
  std::vector<std::array<uint8_t, 0x2000>> ram_banks_{};
  uint8_t active_rom_bank_ = 0;
  uint8_t active_ram_bank_ = 0;
  bool ram_banking_mode_{};
  bool ram_enabled_{};
  void SelectRomBank(uint8_t bank);
  void SelectRamBank(uint8_t bank);
  CartridgeType memory_bank_controller_{};
  // Memory Banking
  // We use "1" bank for both the 2kB and full 8kB single bank scenarios
  const uint8_t external_ram_size_[6] = {0, 1, 1, 4, 16, 8};
  // Boot ROM
  const uint8_t boot_rom_[256] = {
      0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB,
      0x21, 0x26, 0xFF, 0x0E, 0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3,
      0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0, 0x47, 0x11, 0x04, 0x01,
      0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
      0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22,
      0x23, 0x05, 0x20, 0xF9, 0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99,
      0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20, 0xF9, 0x2E, 0x0F, 0x18,
      0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
      0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20,
      0xF7, 0x1D, 0x20, 0xF2, 0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62,
      0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06, 0x7B, 0xE2, 0x0C, 0x3E,
      0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
      0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17,
      0xC1, 0xCB, 0x11, 0x17, 0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
      0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83,
      0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
      0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63,
      0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
      0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C, 0x21, 0x04, 0x01, 0x11,
      0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
      0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE,
      0x3E, 0x01, 0xE0, 0x50};
};

#endif  // !MMU_H
